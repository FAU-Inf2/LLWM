#!/usr/bin/python3

#TODO harder constrains on the inputs
#TODO prevent the discovery of the same echoeing point twice


import sys
import os
import re
import fnmatch as match

#parameters for the klee search
newmain=False
lensymargs=3
numsymargs=1
maxsymargs=1
timeout=360 #timeout for klee search

def translateBack(s,numinputs):
	rets=""
	for c in s:
		if(c=='\x11'):
			rets+=';'
		elif(c=='\x12'):
			rets+=' '
		elif(c=='\x13'):
			rets+=":"
		elif(c=='\x14'):
			rets+="\x00"
		else:
			rets+=c
			
	return rets



#helper function to strip unnecessary null bytes
#unnecessary null bytes are subsequent null bytes
#they can sometimes occur on inputs that are generated by klee
#the first nullbyte of a word gets replaced by 
def stripNullBytes(s,numinputs,leninputs):

	strippedS=""
	curin=0
	curchar=0
	curblck=False
	skipnext=False
	for c in s:
		if(not skipnext):
			if(not curblck):
				if(c==';'):
					strippedS+="\x11"
				elif(c==' '):
					strippedS+="\x12"
				elif(c==':'):
					strippedS+="\x13"
				elif(c=='\x00'):
					#check if first char of current input
					if(curchar==0):
						#signal that input is empty (There has to be a better way than this but i dont know right now)
						strippedS+="\x14"
					#check if input is last input
					if(not curin==numinputs-1):
						#append a blank as seperator and mark word as finished
						strippedS+=" "
					curblck=True
				else:
					strippedS+=c
			curchar+=1;
			if(curchar==leninputs):
				skipnext=True
				curblck=False
				curchar=0
				curin+=1
			if(curin==numinputs):
				break
		else:
			skipnext=False
	
	return strippedS

#parses the klee file at the given relative Path to a string representing the output
def parseKlee(relativePath,outfile):	
	if(relativePath[-1]!='/'):
		relativePath+="/"

	directory=os.getcwd()+"/"+relativePath
	flag=False
	
	for root, direct, files in os.walk(directory):
		for file in files:
			if match.fnmatch(file,"*.assert.err"):
				#found an injected assertion error
				otfile=open(outfile,"w+")
				otfile.close()
				cmdline="ktest-tool "+relativePath+file.split('.')[0]+".ktest > "+outfile			
				os.system(cmdline)
				flag=True
				break
		
	if flag==False:
		return ""
		
	fp=open(outfile)
	#handle the output of ktest-tool
	outstring=""
	tempstring=""
	objectindex=0
	#name=False
	for line in fp:
		objectstring="object "+str(objectindex)+"*"
		if match.fnmatch(line,objectstring):
			#print(line.strip('\n'))
			#filter out arg
			#if match.fnmatch(line,"object *: name:*"):
			#	if line.split(':')[2].strip(' ').strip('\n')!="'model_version'":
			#		name=True
			if match.fnmatch(line,"object *: int :*") and newmain==True:
				tempstring=line.split(':')[2].strip(' ').strip('\n')
			elif match.fnmatch(line,"object *: hex :*") and newmain==False:
				teststring=line.split(':')[2][3:lensymargs*2+3].strip(' ').strip('\n')
				tempstring=str(bytearray.fromhex(teststring).decode())
			
		else:
			if match.fnmatch(line,"object *"):
				#for c in tempstring:
				#	print(ascii(c))
				if len(outstring)!=0:
					outstring+=" "+tempstring
				else:
					outstring+=tempstring
				objectindex+=1
				tempstring=""
				#name=False
	
	outstring+=""		
	return outstring
	

#returns an inputstring for given index or None if none is found
def recoverSingleInput(index,llfile,previnput,prevdict,idxmax,maxdepth):
	outstring=""
	for curnumargs in range(numsymargs,maxsymargs+1):
		if(newmain==True):
			#injecting a new main
			cmdline="opt -load ../../llvm/llvm-project/build/lib/LLVMInstrumentKlee.so -InstrumentKlee -depth "+str(maxdepth)+" -ind "+str(index)+" -nmain 1"+" -S <"+llfile+".ll> "+llfile+"-kleed.ll"
			os.system(cmdline)
			cmdline="llvm-as "+llfile+"-kleed.ll -o "+llfile+"-kleed.bc"
			os.system(cmdline)
			cmdline="klee "+llfile+"-kleed.bc"
			os.system(cmdline)		
		else:	
			#only instrument points at index
			cmdline="opt -load ../../llvm/llvm-project/build/lib/LLVMInstrumentKlee.so -InstrumentKlee -depth "+str(maxdepth)+" -ind "+str(index)+" -nmain 0"+" -bl \"\""+" -S <"+llfile+".ll> "+llfile+"-kleed.ll"
			os.system(cmdline)
			#call klee with --symarg [length] for every argument
			cmdline="klee  --exit-on-error-type=Assert"+" --max-time="+str(timeout)+"s"+" --watchdog --libc=uclibc --posix-runtime ./"+llfile+"-kleed.ll"+" --sym-args "+str(curnumargs)+" "+str(curnumargs)+" "+str(lensymargs)+" --sym-stdin 1 >/dev/null"
			os.system(cmdline)
		#this part must be performed always
		outstring=parseKlee("klee-out-0","outfile-"+str(index))
	
		outstring=stripNullBytes(outstring,curnumargs,lensymargs)
		
		#cleanup
		#cmdline="rm "+llfile+"-kleed.ll"
		#os.system(cmdline)
		if(newmain==True):
			cmdline="rm "+llfile+"-kleed.bc"
			os.system(cmdline)
		cmdline="rm klee-last"
		os.system(cmdline)
		cmdline="rm -r klee-out-0"
		os.system(cmdline)
		cmdline="rm outfile-"+str(index)
		os.system(cmdline)
	
		duplicateFlag=False
		#check if input is different from previous
		if(not previnput is None):
			if(outstring==previnput):
				if(newmain==False):
					
					#previnput=stripNullBytes(previnput,numsymargs,lensymargs)
				
					blockinput=previnput		
				
					#maybe we can derive a different outstring in such cases
					cmdline="opt -load ../../llvm/llvm-project/build/lib/LLVMInstrumentKlee.so -InstrumentKlee -depth "+str(maxdepth)+" -ind "+str(index)+" -nmain 0"+" -bl "+'"'+blockinput+'"'+" -S <"+llfile+".ll> "+llfile+"-2kleed.ll"
				
					os.system(cmdline)
					#call klee with --symarg [length] for every argument
					cmdline="klee --exit-on-error-type=Assert"+" --max-time="+str(timeout)+"s"+" --watchdog --libc=uclibc --posix-runtime ./"+llfile+"-2kleed.ll"+" --sym-args "+str(curnumargs)+" "+str(curnumargs)+" "+str(lensymargs)+" --sym-stdin 1 >/dev/null"
					os.system(cmdline)
					outstring=parseKlee("klee-out-0","outfile-"+str(index))
				
					#print("outstring: ")
					#for c in outstring:
					#	print(ascii(c))
				
					outstring=stripNullBytes(outstring,curnumargs,lensymargs)
					
					
					#print("outstring: ")
					#for c in outstring:
					#	print(ascii(c))
			
					#print("previnput")
					#if(not previnput is None):
					#	for c in previnput:
					#		print(ascii(c))
					
					
					
					#for c in outstring:
					#	print(ascii(c))
					#cleanup
					duplicateFlag=True
				
					cmdline="rm klee-last"
					os.system(cmdline)
					cmdline="rm -r klee-out-0"
					os.system(cmdline)
	
	
		if(outstring==""):
			if(duplicateFlag):
				cmdline="rm "+llfile+"-2kleed.bc"
				os.system(cmdline)
			return None
	
		if(duplicateFlag):
			cmdline="mv "+llfile+"-2kleed.bc "+llfile+"-kleed.bc "
			os.system(cmdline)
	
	
		#for c in outstring:
		#	print(ascii(c))
			
		#if(not previnput is None):
		#	for c in previnput:
		#		print(ascii(c))
	
		redo=False
		blockstring=previnput
		blsl=[previnput]
		#print(prevdict)
		if(len(prevdict.keys())>0):
			#print(list(prevdict.keys())[-1])
			key=list(prevdict.keys())[-1]
			conflictlist=prevdict[key]
			for item in conflictlist:
		   		#cmdline="opt -load ../../llvm/llvm-project/build/lib/LLVMInstrumentKlee.so -InstrumentKlee -depth "+str(maxdepth)+" -ind 42 -nmain 2 -bl "+'"'+item+'"'+" -S <"+llfile+".ll> "+llfile+"-2kleed.ll"
		   		#os.system(cmdline)
		   		#cmdline="mv "+llfile+"-2kleed.bc "+llfile+"-kleed.bc "
		   		#os.system(cmdline)
		   		if(not item in blsl):
		   			blsl.append(item)
		   			blockstring=blockstring+" "+item
		   		if(item==outstring):
		   			#print("CONFLICT!")
		   			redo=True
		
		#check if newly derived input is in dictionary
		
		for key in prevdict:
		
			#check if index conflicts with key
			if(key//idxmax==index//idxmax or
		  	 key//idxmax==index%idxmax or
		  	 key%idxmax==index//idxmax or
		   	key%idxmax==index%idxmax):
		   		conflictlist=prevdict[key]
		   		for item in conflictlist:
		   			#cmdline="opt -load ../../llvm/llvm-project/build/lib/LLVMInstrumentKlee.so -InstrumentKlee -depth "+str(maxdepth)+" -ind 42 -nmain 2 -bl "+'"'+item+'"'+" -S <"+llfile+".ll> "+llfile+"-2kleed.ll"
		   			#os.system(cmdline)
		   			#cmdline="mv "+llfile+"-2kleed.bc "+llfile+"-kleed.bc "
		   			#os.system(cmdline)
		   			if(not item in blsl):
		   				blsl.append(item)
		   				blockstring=blockstring+" "+item
		   			
		   			if(item==outstring):
		   				redo=True
		if(redo):
			
			cmdline="opt -load ../../llvm/llvm-project/build/lib/LLVMInstrumentKlee.so -InstrumentKlee -depth "+str(maxdepth)+" -ind "+str(index)+" -nmain 0 -bl "+'"'+blockstring+'"'+" -S <"+llfile+".ll> "+llfile+"-2kleed.ll"
			os.system(cmdline)
			
			#if(not previnput==None):
			#	for c in blockstring:
			#		print(ascii(c))
			
			
		
		
		
			cmdline="klee --exit-on-error-type=Assert"+" --max-time="+str(timeout)+"s"+" --watchdog --libc=uclibc --posix-runtime ./"+llfile+"-2kleed.ll"+" --sym-args "+str(curnumargs)+" "+str(curnumargs)+" "+str(lensymargs)+" --sym-stdin 1 >/dev/null"
			os.system(cmdline)
			outstring=parseKlee("klee-out-0","outfile-"+str(index))
			
			#print("outstring:")
			#for c in outstring:
			#	print(ascii(c))
		
			outstring=stripNullBytes(outstring,curnumargs,lensymargs)
			
			#print("outstring:")
			#for c in outstring:
			#	print(ascii(c))
			
			#if(index==6):
			#	i=i/0
	
		
		cmdline="rm "+llfile+"-2kleed.bc"
		os.system(cmdline)
		if(not outstring==""):
			return outstring
	
	if(outstring==""):
		return None
	
	#print(prevdict)
	#print(index)
	#print(outstring)
	
	return outstring

#checks if index is sensible for given length
def checkIndex(index,length,lastindex):
	if(int(index)/int(length)>=int(index)%int(length)):
		#print("Index "+str(index)+" skipped")
		return False
	if((lastindex==-1) or (int(int(index)/int(length))==int(int(lastindex)/int(length))) or (int(int(index)%int(length))==int(int(lastindex)/int(length))) or (int(int(index)/int(length))==int(int(lastindex)%int(length))) or (int(int(index)%int(length))==int(int(lastindex)%int(length)))):
		return True
	#print("Index "+str(index)+" is no echo to "+str(lastindex))
	return False

#attempts to recover an input sequence of length while avoiding indices in blocklist
#returns a tuple of indices and inputs or None if none could be found
def recoverInputSequence(llfile,maxindex,length,blocklist,lastindex,previnput,prevdict,maxdepth):
	#print("blocklist: "+str(blocklist))
	#print("prevdict: "+str(prevdict))
	#print("maxindex: "+str(maxindex))
	#print("lastindex: "+str(lastindex))
	
	#try every valid index
	for index in range(int(maxindex)*int(maxindex)):
		
		#check if index is viable
		if(checkIndex(index,maxindex,lastindex) and not (index in blocklist)):  
			#print(index)
			newinput=recoverSingleInput(index,llfile,previnput,prevdict,int(maxindex),maxdepth)
			if(not(newinput==None)):
				#print(index)
				#basecase
				if(length==1):
					return (index,newinput)
				#attempt to recursively find rest of the sequence
				bl=blocklist.copy()
				bl.append(index)
				
				#restrict indices that include the last discovered echoeing point
				if(len(bl)>1):
					firsti=index
					scndi=lastindex
					echoept=-1
					if( int(int(firsti)/int(maxindex))==int(int(scndi)/int(maxindex)) or (int(int(firsti)/int(maxindex))==int(int(scndi)%int(maxindex)))):
						echoept=int(int(firsti)/int(maxindex))
					elif((int(int(firsti)%int(maxindex))==int(int(scndi)/int(maxindex))) or (int(int(firsti)%int(length))==int(int(scndi)%int(maxindex)))):
						echoept=int(int(firsti)%int(maxindex))
					
					else:
						print("something broke")
						
					#print("echoeing point is: "+str(echoept))
						
					for blitem in range(int(maxindex)*int(maxindex)):
						if(blitem in bl):
							continue
						#block points that include the echoeing point
						if(int(int(blitem)/int(maxindex))==echoept):
							#print("added to bl: "+str(blitem))
							bl.append(blitem)
						elif(int(int(blitem)%int(maxindex))==echoept):
							#print("added to bl: "+str(blitem))
							bl.append(blitem)
				
				
				if(lastindex!=-1):
					if lastindex in prevdict:
						prevdict[lastindex].append(previnput)
					else:
						prevdict[lastindex]=[previnput]
				
				otherinputs=recoverInputSequence(llfile,maxindex,length-1,bl,index,newinput,prevdict,maxdepth)
				if(not(otherinputs==None)):
					return (str(otherinputs[0])+","+str(index),str(otherinputs[1])+":"+str(newinput))
	return None
	
#entry point
os.system("ulimit -s unlimited")
#arg1=filename
llfile=sys.argv[1]
#arg2=maxindex
maxind=int(sys.argv[2])
#arg3=length of sequence
length=int(sys.argv[3])
#arg4=depth of loops to consider
maxdepth=int(sys.argv[4])
#arg5=newmain
if(int(sys.argv[5])!=0):
	newmain=True

else:
	#arg6=length of symbolic arguments
	lensymargs=int(sys.argv[6])
	#arg7 numsymargs
	numsymargs=int(sys.argv[7])
	maxsymargs=numsymargs
	if(len(sys.argv)>7):
		#arg8 maxsymargs
		maxsymargs=int(sys.argv[8])

if(maxdepth<0):
	print("maxdepth must be a non-negative number")
	quit()	
if(length<=0):
	print("length must be a positive number")
	quit()
rettuple=recoverInputSequence(llfile,maxind,length,[],-1,None,{},maxdepth)
if(rettuple==None):
	print("No suitable input sequence found!")
	quit()
	
retstring=str(rettuple[0])+";"+str(rettuple[1]);
#for c in retstring:
#	print(ascii(c))
print(str(rettuple[0])+";"+str(rettuple[1]))
quit()

	
	



